<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8" />
    <title>MecLib / JSXGraph Aufgabe</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- JSXGraph CSS -->
    <link rel="stylesheet" href="https://jsxgraph.org/distrib/jsxgraph.css" />

    <!-- JSXGraph JS -->
    <script src="https://jsxgraph.org/distrib/jsxgraphcore.js"></script>

    <!-- Deine MecLib-/ONYX-Erweiterung aus GitHub -->
    <script src="https://cdn.jsdelivr.net/gh/Fkaule/TM_JSX_Graph@main/MecLibONYX.js"></script>

    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 1rem;
        }

        h1 {
            font-size: 1.4rem;
            margin-bottom: 0.5rem;
        }

        #JSX_CONTAINER_ID {
            width: 700px;
            height: 260px;
        }
    </style>
</head>

<body>
    <h1>Interaktive MecLib-Aufgabe</h1>

    <!-- Container für das Board -->
    <div id="JSX_CONTAINER_ID" class="jxgbox"></div>

    <script>
        // =====================================================================
        // === ONYX-CODE HIER EINFÜGEN =========================================
        // =====================================================================

        document.getElementById('JSX_CONTAINER_ID').style.border = "none";
        /****************************************************
         * Sch&ouml;nes Styling (analog Referenzbild)
         * - gro&szlig;e Schrift, kr&auml;ftige Pfeile, klare Farben
         * - links: festes Rechteck + drehendes KS (&xi;, &eta;)
         * - rechts: Momentenverl&auml;ufe (gestrichelt)
         ****************************************************/
        const cfg = {
            boardWidthPx: 700,
            boardHeightPx: 400,
            bbox: { left: -34, top: 30, right: 34, bottom: -7 },  // extra breit/hoch

            // Layout
            leftFrac: 1 / 3,
            gapX: 2.4,
            padLeft: 1.0,
            padRight: 1.0,
            padY: 2.0,

            // Rechteck
            rectWidthRatio: 0.86,
            rectHeightRatio: 0.58,

            // Slider (0..180°, nur ganze Grad + eigenes Label)
            sliderY: -6.2,

            // Label-Offsets
            axisLabelOffset: 1.1,   // Abstand &xi;/&eta;-Label hinter Pfeilspitze
            xbarLabelDx: 0.75,
            ybarLabelDy: 1.5,
            ybarLabelDx: 0.55,
            graphPhiLabelDx: 0.0,
            graphPhiLabelDown: -2,
            graphJLabelDy: -2,
            gridLabelDy: -2,

            // Typografie (px)
            font: {
                base: 16,
                axes: 20,
                big: 22,
                legend: 16,
                grid: 14
            },

            // Farben (angelehnt an Beispiel)
            col: {
                rectFill: '#a8d4ff',   // helles Blau im Innenbereich
                rectEdge: '#2b4c7e',   // dunklere Kante
                baseAxes: '#000000',   // gr&uuml;n: \bar{x}, \bar{y}
                xiAxis: '#d33',      // rot: &xi;
                etaAxis: '#1f6aff',   // blau: &eta;
                frame: '#e5e5e5',
                grid: '#d0d0d0',
                xiXiLine: '#cc7a7a', xiXiPt: '#e00',
                etaEtaLine: '#7a7acc', etaEtaPt: '#06f',
                xiEtaLine: '#6aa06a', xiEtaPt: '#0a0'
            },

            // Strichst&auml;rken
            sw: {
                rect: 2.5,
                baseAxes: 3,
                rotAxes: 3.2,
                graphAxes: 1.6,
                grid: 1,
                curves: 2.6
            },

            // Markergr&ouml;&szlig;e
            marker: 5
        };

        /* ===== Board ===== */
        const el = document.getElementById('JSX_CONTAINER_ID');
        el.style.width = cfg.boardWidthPx + 'px';
        el.style.height = cfg.boardHeightPx + 'px';

        let brd = JXG.JSXGraph.initBoard('JSX_CONTAINER_ID', {
            boundingbox: [cfg.bbox.left, cfg.bbox.top, cfg.bbox.right, cfg.bbox.bottom],
            axis: false,
            keepaspectratio: true,
            showNavigation: false,
            showCopyright: false
        });

        /* ===== Aufteilung (1/3 : 2/3) ===== */
        const L = cfg.bbox.left, R = cfg.bbox.right, T = cfg.bbox.top, B = cfg.bbox.bottom;
        const W = R - L, split = L + W * cfg.leftFrac;

        const leftX0 = L, leftX1 = split - cfg.gapX;
        const rightX0 = split + cfg.gapX, rightX1 = R;

        const leftInnerX0 = leftX0 + cfg.padLeft;
        const leftInnerX1 = leftX1 - cfg.padLeft;
        const rightInnerX0 = rightX0 + cfg.padRight;
        const rightInnerX1 = rightX1 - cfg.padRight;
        const innerYTop = T - cfg.padY;
        const innerYBot = B + cfg.padY;

        /* ===== LINKS: Rechteck + drehendes KS ===== */
        const totalH = T - B;
        const rectW = (leftInnerX1 - leftInnerX0) * cfg.rectWidthRatio;
        const rectH = totalH * cfg.rectHeightRatio;

        const cx = (leftInnerX0 + leftInnerX1) / 2;
        const cy = (innerYTop + innerYBot) / 2;
        const b = rectW, h = rectH;

        // Rechteck
        const A = brd.create('point', [cx - b / 2, cy - h / 2], { visible: false, fixed: true });
        const Bp = brd.create('point', [cx - b / 2, cy + h / 2], { visible: false, fixed: true });
        const C = brd.create('point', [cx + b / 2, cy + h / 2], { visible: false, fixed: true });
        const D = brd.create('point', [cx + b / 2, cy - h / 2], { visible: false, fixed: true });

        brd.create('polygon', [A, Bp, C, D], {
            borders: { strokeColor: cfg.col.rectEdge, strokeWidth: cfg.sw.rect },
            fillColor: cfg.col.rectFill,
            fillOpacity: 0.85,
            fixed: true, highlight: false
        });

        // \bar{x}, \bar{y} als Pfeile (optisch wie im Beispiel)
        const baseXpos = [cx + b / 2 + 0.3, cy],
            baseXneg = [cx - b / 2 - 0.3, cy],
            baseYpos = [cx, cy + h / 2 + 0.3],
            baseYneg = [cx, cy - h / 2 - 0.3];

        brd.create('segment', [baseXneg, [cx, cy]], { strokeColor: cfg.col.baseAxes, strokeWidth: cfg.sw.baseAxes, fixed: true, highlight: false });
        brd.create('arrow', [[cx, cy], baseXpos], { strokeColor: cfg.col.baseAxes, strokeWidth: cfg.sw.baseAxes, fixed: true, highlight: false });
        brd.create('segment', [baseYneg, [cx, cy]], { strokeColor: cfg.col.baseAxes, strokeWidth: cfg.sw.baseAxes, fixed: true, highlight: false });
        brd.create('arrow', [[cx, cy], baseYpos], { strokeColor: cfg.col.baseAxes, strokeWidth: cfg.sw.baseAxes, fixed: true, highlight: false });

        // Labels (HTML f&uuml;r sch&ouml;ne Typo)
        brd.create('text', [cx + cfg.ybarLabelDx, cy + h / 2 + cfg.ybarLabelDy,
        "<span style='font-size:" + cfg.font.axes + "px; color:" + cfg.col.baseAxes + "; font-family:serif; font-style:italic;'>y</span>"],
            { fixed: true, display: 'html' });

        brd.create('text', [cx + b / 2 + cfg.xbarLabelDx, cy - 0.1,
        "<span style='font-size:" + cfg.font.axes + "px; color:" + cfg.col.baseAxes + "; font-family:serif; font-style:italic;'>x</span>"],
            { fixed: true, display: 'html' });

        // Slider &phi;: nur ganze Grad, eigenes Label + Anzeige
        let sPhi = brd.create('slider',
            [[leftInnerX0, cfg.sliderY], [leftInnerX1, cfg.sliderY], [0, 0, 180]],
            { withLabel: false, snapWidth: 1 }
        );
        brd.create('text', [leftInnerX0 + (leftInnerX1 - leftInnerX0) / 2, cfg.sliderY + 2.5,
        "<span style='font-size:" + cfg.font.base + "px; font-family:serif; font-style:italic;'>&phi;</span>"],
            { fixed: true, display: 'html' });

        brd.create('text', [
            () => leftInnerX1 + 0.6,
            () => cfg.sliderY - 0.02,
            () => "<span style='font-size:" + cfg.font.base + "px;'>" + Math.round(sPhi.Value()) + "°</span>"
        ], { fixed: true, display: 'html', anchorX: 'left' });

        // Rotierendes &xi;/&eta;-KS (Pfeile + Labels, farblich wie Graph)
        function phi() { return sPhi.Value() * Math.PI / 180; }
        function phiEta() { return phi() + Math.PI / 2; }

        const rMax = Math.min(cx - leftInnerX0, leftInnerX1 - cx, cy - innerYBot, innerYTop - cy);
        const Laxis = rMax * 0.98;
        const Llabel = Laxis + cfg.axisLabelOffset;

        function pt(getAng) { return [() => cx + Laxis * Math.cos(getAng()), () => cy + Laxis * Math.sin(getAng())]; }
        function ptNeg(getAng) { return [() => cx - Laxis * Math.cos(getAng()), () => cy - Laxis * Math.sin(getAng())]; }

        // &xi; (rot)
        const xiPos = brd.create('point', pt(() => phi()), { visible: false, fixed: true });
        const xiNeg = brd.create('point', ptNeg(() => phi()), { visible: false, fixed: true });
        brd.create('segment', [xiNeg, [cx, cy]], { strokeColor: cfg.col.xiAxis, strokeWidth: cfg.sw.rotAxes, fixed: true, highlight: false });
        brd.create('arrow', [[cx, cy], xiPos], { strokeColor: cfg.col.xiAxis, strokeWidth: cfg.sw.rotAxes, fixed: true, highlight: false });
        brd.create('text', [() => cx + Llabel * Math.cos(phi()), () => cy + Llabel * Math.sin(phi()),
        "<span style='font-size:" + cfg.font.big + "px; color:" + cfg.col.xiAxis + "; font-family:serif; font-style:italic;'>&xi;</span>"],
            { fixed: true, display: 'html' });

        // &eta; (blau)
        const etaPos = brd.create('point', pt(() => phiEta()), { visible: false, fixed: true });
        const etaNeg = brd.create('point', ptNeg(() => phiEta()), { visible: false, fixed: true });
        brd.create('segment', [etaNeg, [cx, cy]], { strokeColor: cfg.col.etaAxis, strokeWidth: cfg.sw.rotAxes, fixed: true, highlight: false });
        brd.create('arrow', [[cx, cy], etaPos], { strokeColor: cfg.col.etaAxis, strokeWidth: cfg.sw.rotAxes, fixed: true, highlight: false });
        brd.create('text', [() => cx + Llabel * Math.cos(phiEta()), () => cy + Llabel * Math.sin(phiEta()),
        "<span style='font-size:" + cfg.font.big + "px; color:" + cfg.col.etaAxis + "; font-family:serif; font-style:italic;'>&eta;</span>"],
            { fixed: true, display: 'html' });

        /* ===== RECHTS: Verl&auml;ufe I&xi;&xi;(&phi;), I&eta;&eta;(&phi;), I&xi;&eta;(&phi;) &ndash; mit gemeinsamer Y-Skalierung ===== */
        const Ix = b * Math.pow(h, 3) / 12;
        const Iy = h * Math.pow(b, 3) / 12;
        const Ixy = 0;

        function I_xixi(t) {
            return (Ix + Iy) / 2 + (Ix - Iy) / 2 * Math.cos(2 * t) + Ixy * Math.sin(2 * t);
        }
        function I_etaeta(t) {
            return (Ix + Iy) / 2 - (Ix - Iy) / 2 * Math.cos(2 * t) - Ixy * Math.sin(2 * t);
        }
        function I_xieta(t) {
            return (Iy - Ix) / 2 * Math.sin(2 * t) + Ixy * Math.cos(2 * t);
        }

        const gxMin = rightInnerX0, gxMax = rightInnerX1;
        const tMin = 0, tMax = Math.PI;
        function mapPhiToX(t) {
            return gxMin + (t - tMin) / (tMax - tMin) * (gxMax - gxMin);
        }

        // === Gemeinsamer Wertebereich f&uuml;r alle Momente
        const sampleTs = [];
        for (let t = 0; t <= Math.PI; t += Math.PI / 180) sampleTs.push(t);

        const Ivals = sampleTs.flatMap(t => [I_xixi(t), I_etaeta(t), I_xieta(t)]);
        const Imin = Math.min(...Ivals);
        const Imax = Math.max(...Ivals);
        const Ieps = 0.1 * (Imax - Imin);

        const Ilo = Imin - Ieps;
        const Ihi = Imax + Ieps;

        function mapItoY(I) {
            return innerYBot + (I - Ilo) / (Ihi - Ilo) * (innerYTop - innerYBot);
        }


        // Rahmen
        const segFix = { strokeColor: cfg.col.frame, strokeWidth: 1.2, fixed: true, highlight: false };
        brd.create('segment', [[gxMin, innerYBot], [gxMax, innerYBot]], segFix);
        brd.create('segment', [[gxMin, innerYTop], [gxMax, innerYTop]], segFix);
        brd.create('segment', [[gxMin, innerYBot], [gxMin, innerYTop]], segFix);
        brd.create('segment', [[gxMax, innerYBot], [gxMax, innerYTop]], segFix);

        // Achsenbeschriftung
        const axX = mapPhiToX((tMin + tMax) / 2);
        brd.create('line', [[gxMin, mapItoY(0)], [gxMax, mapItoY(0)]], {
            straightFirst: false, straightLast: false, lastArrow: true,
            strokeWidth: cfg.sw.graphAxes, strokeColor: '#444', fixed: true, highlight: false
        });
        brd.create('text', [gxMax - cfg.graphPhiLabelDx, mapItoY(0) - cfg.graphPhiLabelDown,
        "<span style='font-size:" + cfg.font.base + "px; font-family:serif; font-style:italic;'>&phi;</span>"
        ], { fixed: true, display: 'html', anchorX: 'right' });

        brd.create('line', [[axX, innerYBot - 0.8], [axX, innerYTop]], {
            straightFirst: false, straightLast: false, lastArrow: true,
            strokeWidth: cfg.sw.graphAxes, strokeColor: '#444', fixed: true, highlight: false
        });
        brd.create('text', [axX - 0.35, innerYTop - cfg.graphJLabelDy,
        "<span style='font-size:" + cfg.font.base + "px;'>I<sub>&xi;&xi;</sub>, I<sub>&eta;&eta;</sub>, I<sub>&xi;&eta;</sub></span>"
        ], { fixed: true, display: 'html' });

        // Grid-Linien (&phi; & horizontale bei I=0)
        [0, 45, 90, 135, 180].forEach(deg => {
            const t = deg * Math.PI / 180, x = mapPhiToX(t);
            brd.create('segment', [[x, innerYBot], [x, innerYTop]], {
                strokeColor: cfg.col.grid, dash: 1, strokeWidth: cfg.sw.grid, fixed: true, highlight: false
            });
            brd.create('text', [x, innerYBot + cfg.gridLabelDy,
                "<span style='font-size:" + cfg.font.grid + "px;'>" + deg + "°</span>"
            ], { fixed: true, display: 'html', anchorX: 'middle' });
        });
        brd.create('segment', [[gxMin, mapItoY(0)], [gxMax, mapItoY(0)]], {
            strokeColor: cfg.col.grid, dash: 1, strokeWidth: cfg.sw.grid, fixed: true, highlight: false
        });
        brd.create('text', [gxMin - 0.35, mapItoY(0) + 0.15,
        "<span style='font-size:" + cfg.font.grid + "px;'>0</span>"
        ], { fixed: true, display: 'html' });

        // Kurven
        const dashed = { dash: 2, strokeWidth: cfg.sw.curves, fixed: true, highlight: false };
        brd.create('curve', [t => mapPhiToX(t), t => mapItoY(I_xixi(t)), tMin, tMax],
            Object.assign({}, dashed, { strokeColor: cfg.col.xiXiLine }));
        brd.create('curve', [t => mapPhiToX(t), t => mapItoY(I_etaeta(t)), tMin, tMax],
            Object.assign({}, dashed, { strokeColor: cfg.col.etaEtaLine }));
        brd.create('curve', [t => mapPhiToX(t), t => mapItoY(I_xieta(t)), tMin, tMax],
            Object.assign({}, dashed, { strokeColor: cfg.col.xiEtaLine }));

        // Marker
        function phiRad() {
            return sPhi.Value() * Math.PI / 180;
        }
        brd.create('point', [() => mapPhiToX(phiRad()), () => mapItoY(I_xixi(phiRad()))],
            { name: '', face: 'o', size: cfg.marker, strokeColor: cfg.col.xiXiPt, fillColor: cfg.col.xiXiPt, fixed: true, highlight: false });
        brd.create('point', [() => mapPhiToX(phiRad()), () => mapItoY(I_etaeta(phiRad()))],
            { name: '', face: 'o', size: cfg.marker, strokeColor: cfg.col.etaEtaPt, fillColor: cfg.col.etaEtaPt, fixed: true, highlight: false });
        brd.create('point', [() => mapPhiToX(phiRad()), () => mapItoY(I_xieta(phiRad()))],
            { name: '', face: 'o', size: cfg.marker, strokeColor: cfg.col.xiEtaPt, fillColor: cfg.col.xiEtaPt, fixed: true, highlight: false });

        // Legende
        brd.create('text', [rightInnerX0 - 0.2, mapItoY(Iy),
        "<span style='color:" + cfg.col.etaEtaLine + "; font-size:" + cfg.font.legend + "px;'>I<sub>&eta;&eta;</sub>(&phi;)</span>"
        ], { fixed: true, display: 'html', anchorX: 'right' });
        brd.create('text', [rightInnerX0 - 0.2, mapItoY(Ix),
        "<span style='color:" + cfg.col.xiXiLine + "; font-size:" + cfg.font.legend + "px;'>I<sub>&xi;&xi;</sub>(&phi;)</span>"
        ], { fixed: true, display: 'html', anchorX: 'right' });
        brd.create('text', [rightInnerX0 - 0.2, mapItoY(Ixy),
        "<span style='color:" + cfg.col.xiEtaLine + "; font-size:" + cfg.font.legend + "px;'>I<sub>&xi;&eta;</sub>(&phi;)</span>"
        ], { fixed: true, display: 'html', anchorX: 'right' });

        // Winkelbogen + Pfeil + Label f&uuml;r &phi; (x-Achse &rarr; &xi;-Achse)
        const xRef = brd.create('point', [cx + 1.2, cy], { visible: false });
        const xiRef = brd.create('point', [
            () => cx + 1.2 * Math.cos(phi()),
            () => cy + 1.2 * Math.sin(phi())
        ], { visible: false });

        const angleArc = brd.create('angle', [xRef, [cx, cy], xiRef], {
            radius: 1.2,
            withLabel: false,
            strokeColor: '#000',
            strokeWidth: 2,
            fillColor: 'none',
            fixed: true,
            highlight: false
        });

        // Label &phi; = xx°
        brd.create('text', [
            () => cx + 1.6 * Math.cos(phi() / 2),
            () => cy + 1.6 * Math.sin(phi() / 2),
            () => `<span style="font-size:18px;">&phi; = ${Math.round(sPhi.Value())}°</span>`
        ], {
            fixed: true,
            display: 'html',
            anchorX: 'middle',
            anchorY: 'middle'
        });

        // =====================================================================
        // === ENDE ONYX-CODE ================================================
        // =====================================================================
    </script>
</body>

</html>